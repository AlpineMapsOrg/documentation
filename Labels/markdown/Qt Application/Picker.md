## Picker
The next section describes the label picker. With this feature it is possible to click on the window and evaluate what exactly was at the location of this click. If the user clicked on a label the PickerManager automatically locates the exact feature that was selected and displays additional information about this feature to the user using GUI elements. Overall the picker was designed in a way that it not only supports the detection of which label was clicked on, but could also be easily expanded to work with any other elements.

![[picker-detail.png|center]]

### Pickerbuffer
In order to evaluate what the user clicked on, we need the means to read what is written on the screen. Unfortunately simply reading the main FrameBuffer (what is shown on the screen to the user) doesn't really help us. We therefore created a second FrameBuffer called pickerbuffer. With this FrameBuffer we can store and later retrieve numerical values depending on the position. The value we are storing in the FrameBuffer is an 8 bit value for the type that is stored followed by a 24 bit id for the specific feature (= 32-bit numbers per pixel or 4 x 8-bit RGBA values). 

The 8 bits for the type is mainly used to be future-proof and allow the picker to also evaluate the picking of other types than feature labels. The different types are stored in the PickerTypes enum.  By specifying this type we later have a better way to identify where to look for the picked value when evaluating the picked position.

The subsequent 24 bits are used to identify the feature within their respective types. As mentioned earlier, the FeatureTXT struct creates an internal\_id that auto increments and is unique within the application. This internal\_id was only created because of this picker and is therefore used for those 24 bits.

The pickerbuffer is written to in the Window paint method. As mentioned before it uses the same vertex shader and the same GPU VAO elements as the render pass for the labels. This allows us to place the exact same labels at the exact same positions in our pickerbuffer. 

One important thing to note here is that the pickerbuffer doesn't allow any kind of blending during its render pass. This is the case since the blending of ids wouldn't make any sense and would only result in wrong values.
### nucleus::picker::PickerManager
The main part of the picker is the PickerManager. This class is created by the nucleus::Controller, which allows it to connect both to the qt GUI and to the render window very easily.

Since the PickerManager is currently detecting label features it is necessary to hold a list of all possible features. We therefore also connect to the gpu\_quads\_updated signal similar to the MapLabelFilter. The qt slot update_quads() of the PickerManager is connected to this signal and maps every feature of every tile to a map where the key is the internal\_id and the value the FeatureTXT struct where all usable attributes are stored. 

In order to detect that a click has happened the PickerManager first connects to a few input event listeners that are available from the app/TerrainRendererItem class. In specific we are listening to mouse press, mouse release and mouse movements. Since we have to consider mobile devices we are also listening to the touch event listener (which combines all 3 previous listeners into one). In order to prevent code duplication we added the private methods start\_click\_event and end\_click\_event that are to be called at the appropriate times for both touch and mouse events. In the specific case of the PickerManager we are defining a valid click as the action of clicking/pressing on one position and releasing it without having moved too far away from the position. That means as soon as the mouse moves too far way while the press is still active the click event is automatically cancelled by the PickerManager and even if the mouse moves back to the original click position nothing is registered. Doing this provides us with some advantages. Since movement of the camera relies on dragging across the terrain it is possible to accidentally trigger the picker to start. This would mean that every time the mouse is released while dragging a buffer has to be evaluated (which only decreases the performance unnecessarily). Additionally the position the mouse is being released either a random label is evaluated or it closes a feature detail that is being kept intentionally open while moving the camera. All of those scenarios are not ideal, and we therefore focused on only triggering the picker when an intentional click is being detected.

Once a click has been detected the PickerManager emits the pick\_requested qt signal with position of the click as the argument. This signal is captured by the Window to the pick\_value() slot. This pick\_value method reads the contents of the pickerbuffer at the given position and returns the value as another qt signal called value\_picked which is captured again by our PickerManager in the eval\_pick() slot.

Finally we are able to evaluate this value in the eval\_pick() method. At the start the first 8 bits are evaluated to determine the type of the pick. If the type is 0 the pick is automatically determined to be invalid, meaning that no label has been picked at all. In this case we are emitting the pick\_evaluated signal with an empty parameter. If on the other hand a valid type was found the exact picked value is evaluated and determined. In our case we are searching the m\_pickid\_to\_feature map for the 24 bit id. After the feature has been found the FeatureProperties struct is extracted (by using the get\_feature\_data method of the FeatureTXT struct) and the pick\_evaluated signal is send with the FeatureProperties as a parameter.

### FeatureProperties
FeatureProperties is essentially a struct that holds arbitrary values as key/value pairs. Those key/value pairs are used by the QML GUI to show the detail window. The keys are shown on the detail window in bold above the values. Furthermore the FeatureProperties struct also holds a title value which is shown at the top of the detail window.

![[picker.svg|center]]
### Visualizing with Qt GUI
In order to visualize the transmitted FeatureProperties on the Qt GUI, we are first catching the pick\_evaluated signal in the TerrainRendererItem in the change\_feature() slot. This method checks if the properties changed and caches them. Additionally the list of key/value pairs is also transformed into a QList\<QString\> object (with alternating key and values as elements of this list) which is designated as a Q\_PROPERTY so that it can be used in the QML files. Initially we tried to transmit the whole key/value pairs to the QML, but unfortunately, in order to get this to work in QML a lot of groundwork had to be done. Since it wasn't too important that the key/values could be addressed independently in the QML this improvement was not implemented due to time and unneeded complexity reasons.
After everything has been prepared in the change\_feature() method the feature\_changed signal is emitted by the method which triggers the update in the QML file.

The FeatureDetailWindow.qml contains the structure of the detail window as shown in the above screenshot. The main part that is worth describing in this document is the ListView. Like the name implies, the ListView is responsible to display a list to the screen. In this element the model attribute is set to be the QList\<QString\> variable we just created. Next a delegate has to be assigned. This delegate tells the ListView how a single element should be displayed within this list. We are using a simple ItemDelegate since it inherits simple styling guides which allows the individual elements to be styled perfectly for our needs. In order to display the text we are using a simple *Text* QML element as a sub item of the delegate. The keys of the attributes are styled bold and have a bigger font size. This could be set by using the model.index variable and the use of the modulus operator to alternate the style for even and odd index values.
Additionally we are also linking websites and phone numbers to their corresponding actions. For this we are using the onClicked attribute and fill it with our own JavaScript code. We are mainly detecting if a value starts with http. If this is the case we can call the Qt.openUrlExternally() method which results in an appropriate action. 
In order to allow phone numbers to be callable we are checking whether or not the previous value of each list entry was the key "Phone:" and also use the Qt.openUrlExternally() method. This time we have to prepend the phone number of the "URL" with a "tel:" protocol.

